---
version: 2.1

executors:
  docker_stable:
    docker:
      - image: 'docker:stable'
  docker_terraform:
    docker:
      - image: 'hashicorp/terraform:0.12.25'
    resource_class: 'small'
    shell: /bin/sh -leo pipefail

orbs:
  aws-ecr: circleci/aws-ecr@6.9.1

aliases:
  # git branches filters
  - &except_master_branch
    filters:
      branches:
        ignore: master
  - &only_master_branch
    filters:
      branches:
        only: master


jobs:

  build:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - run:
          name: build | install apk packages
          command: sh .circleci/install-apk-packages.sh
      - run:
          name: build | set env variables
          command: |
            cd terraform/
            terraform init \
              -backend-config="key=${CI_ENVIRONMENT}/${AWS_REGION}/apps.tfstate" \
              -backend-config="bucket=${CIRCLE_PROJECT_REPONAME}" \
              -backend-config="region=${AWS_DEFAULT_REGION}"
      - aws-ecr/build-and-push-image: # https://circleci.com/orbs/registry/orb/circleci/aws-ecr
          account-url: $
          aws-access-key-id: ACCESS_KEY_ID_ENV_VAR_NAME
          aws-secret-access-key: SECRET_ACCESS_KEY_ENV_VAR_NAME
          context: myContext
          create-repo: true
          dockerfile: myDockerfile
          no-output-timeout: 20m
          path: pathToMyDockerfile
          profile-name: myProfileName
          region: AWS_REGION_ENV_VAR_NAME
          repo: myECRRepository
          tag: 'latest,myECRRepoTag'
      - run:
          name: build | nginx-hello
          command: |
            cd apps/nginx-hello
            docker build -f Dockerfile -t ${CIRCLE_PROJECT_REPONAME}:${CIRCLE_SHA1}
      - run:
          name: build | push nginx-hello
          command: |
            docker tag $REPO:$COMMIT $REPO:$TAG
      - run:
          name: aws state | apply tf state s3 bucket
          command: |
            cd terraform/aws_state
            aws s3api get-bucket-location --bucket ${CIRCLE_PROJECT_REPONAME} >/dev/null 2>&1 && \
            echo -e "S3 bucket is already exists" || \
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=30s \
              -refresh=true \
              -target=aws_s3_bucket.tfstate-storage-s3 \
              -var="state_region=${AWS_DEFAULT_REGION}" \
              -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
              -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-${CI_ENVIRONMENT}-tf-state-locks"
      - run:
          name: aws state | apply lock dynamodb table
          command: |
            cd terraform/aws_state
            aws dynamodb list-tables --region ${AWS_REGION} | \
            jq ".TableNames[]" | \
            grep ${CIRCLE_PROJECT_REPONAME}-${CI_ENVIRONMENT}-tf-state-locks >/dev/null 2>&1 && \
            echo -e "DynamoDB table is already exists" || \
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=30s \
              -refresh=true \
              -target=aws_dynamodb_table.tfstate-locks \
              -var="state_region=${AWS_REGION}" \
              -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
              -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-${CI_ENVIRONMENT}-tf-state-locks"

  aws_infra:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - run: *aws_infra_init
      - run:
          name: aws infra | validate
          command: |
            cd terraform/aws_infra
            terraform validate
      - run:
          name: aws infra | plan
          command: |
            cd terraform/aws_infra
            terraform plan \
              -out=".terraform/$(basename ${PWD}).tfplan" \
              -var="cluster_name=${CIRCLE_PROJECT_REPONAME}" \
              -var="environment=${CI_ENVIRONMENT}" \
              -var="region=${AWS_REGION}" \
              -var-file=${CI_ENVIRONMENT}.tfvars
      - run:
          name: aws infra | apply
          command: |
            cd terraform/aws_infra
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=30s \
              -refresh=true \
              .terraform/$(basename ${PWD}).tfplan
      - run:
          name: aws infra | make kubeconfig
          command: |
            mkdir -p ~/.kube/
            terraform output kubeconfig > ~/.kube/config 2>/dev/null || echo -e "kubeconfig var is not present"
      - persist_to_workspace:
          root: '~/'
          paths:
            - 'repo/terraform/*'
            - '.kube/*'

  aws_infra_apps:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run:
          name: aws infra apps | .kube dir
          command: mv -f .kube/ ~/
      - run:
          name: aws infra apps | install aws cli
          command: sh .circleci/aws-cli-install.sh
      - kubernetes/install
      - aws-eks/install-eksctl
      - aws-eks/update-kubeconfig-with-authenticator:
          aws-region: "${AWS_REGION}"
          cluster-name: "${CIRCLE_PROJECT_REPONAME}"
      - run: *aws_infra_apps_init
      - run:
          name: aws infra apps | plan
          command: |
            cd terraform/aws_infra_apps
            terraform plan \
            -out=".terraform/$(basename ${PWD}).tfplan" \
            -var="cluster_name=${CIRCLE_PROJECT_REPONAME}" \
            -var="environment=${CI_ENVIRONMENT}" \
            -var="region=${AWS_REGION}"
      - run:
          name: aws infra apps | apply
          command: |
            cd terraform/aws_infra_apps
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=30s \
              -refresh=true \
              .terraform/$(basename ${PWD}).tfplan


workflows:
  eks-prod:
    jobs:
      - aws_state:
          context: env-prod
          <<: *only_master_branch
      - approve_prod:
          type: approval
          <<: *only_master_branch
          requires:
            - aws_state
      - aws_infra:
          context: env-prod
          <<: *only_master_branch
          requires:
            - approve_prod
      - aws_infra_apps:
          context: env-prod
          <<: *only_master_branch
          requires:
            - aws_infra

  eks-staging:
    jobs:
      - aws_state:
          context: env-staging
          <<: *except_master_branch
      - aws_infra:
          context: env-staging
          <<: *except_master_branch
          requires:
            - aws_state
      - aws_infra_apps:
          context: env-staging
          <<: *except_master_branch
          requires:
            - aws_infra
